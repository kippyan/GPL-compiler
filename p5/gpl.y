 /* updated January 2019 * Copy the following token declarations into your .y file. */

 /* Tokens with angle braces < > after %token require a type. 
  * This is the type of the variable the scanner (flex) puts into the union.
  * Fill in the < > with the appropriate union variable
  *     for example
  *     %token <union_int> T_INT_CONSTANT       "int constant" 
  */

%{
  
extern int yylex();  // prototype of function generated by flex
extern int yyerror(const char *); // used to print errors
extern int line_count;            // current line in the input; from record.l

#include "error.h"      // class for printing errors (used by gpl)
#include "parser.h"
// add new includes above this line 
#include <iostream>
#include <string>
using namespace std;

template <typename BINOP, Operator_type NM>
Expression* Bin_op_check(Expression* one, Expression* three, unsigned int valid_types)
{
  unsigned int lh_valid = one->type() & valid_types;
  unsigned int rh_valid = three->type() & valid_types;
  if(!lh_valid){
    Error::error(Error::INVALID_LEFT_OPERAND_TYPE, operator_to_string(NM));
  }
  if(!rh_valid){
    Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, operator_to_string(NM));
  }
  if(lh_valid && rh_valid){
    return new BINOP(one, three);
  }
  else
  {
    delete one;
    delete three;
    return new Integer_constant(0);
  }
}

template <typename UNOP, Operator_type NM>
Expression* Un_op_check(Expression* one, unsigned int valid_types){
  
  unsigned int valid = one->type() & valid_types;
  if(!valid){
    Error::error(Error::INVALID_RIGHT_OPERAND_TYPE, operator_to_string(NM));
    delete one;
    return new Integer_constant(0);
  }
  else
    return new UNOP(one);
}

// bison syntax to indicate the end of the header
%} 

%union {
 int            union_int;
 std::string*   union_string;  // MUST be a pointer to a string
 double 	      union_double;	
 Gpl_type 	    union_gpl_type;
 Expression* 	  union_expression_ptr;
 Parameter*     union_parameter_ptr;
 Statement*     union_statement_ptr;
 //keystroke
};

%destructor {delete $$;} <union_string> /*the parser uses this line to release memory allocated in the scanner when it encounters a syntax error*/
// turn on verbose (longer) error messages
%error-verbose

// tokens declared here
%token T_INT                 "int"
%token T_DOUBLE              "double"
%token T_STRING              "string"
%token T_TRIANGLE            "triangle"
%token T_PIXMAP              "pixmap"
%token T_CIRCLE              "circle"
%token T_RECTANGLE           "rectangle"
%token T_TEXTBOX             "textbox"
%token <union_int> T_FORWARD         "forward"  /* value is line number */
%token T_INITIALIZATION      "initialization"
%token T_TERMINATION          "termination"

%token T_TRUE                "true"
%token T_FALSE               "false"

%token T_TOUCHES             "touches"
%token T_NEAR                "near"

%token T_ANIMATION           "animation"

%token T_IF                  "if"
%token T_FOR                 "for"
%token T_ELSE                "else"
%token <union_int> T_PRINT           "print"  /* value is line number */
%token <union_int> T_EXIT            "exit"  /* value is line number */

%token T_LPAREN              "("
%token T_RPAREN              ")"
%token T_LBRACE              "{"
%token T_RBRACE              "}"
%token T_LBRACKET            "["
%token T_RBRACKET            "]"
%token T_SEMIC               ";"
%token T_COMMA               ","
%token T_PERIOD              "."

%token T_ASSIGN              "="
%token T_PLUS_ASSIGN         "+="
%token T_MINUS_ASSIGN        "-="
%token T_PLUS_PLUS           "++"
%token T_MINUS_MINUS         "--"

%token T_MULTIPLY            "*"
%token T_DIVIDE              "/"
%token T_MOD                 "%"
%token T_PLUS                "+"
%token T_MINUS               "-"
%token T_SIN                 "sin"
%token T_COS                 "cos"
%token T_TAN                 "tan"
%token T_ASIN                "asin"
%token T_ACOS                "acos"
%token T_ATAN                "atan"
%token T_SQRT                "sqrt"
%token T_FLOOR               "floor"
%token T_ABS                 "abs"
%token T_RANDOM              "random"

%token T_LESS                "<"
%token T_GREATER             ">"
%token T_LESS_EQUAL          "<="
%token T_GREATER_EQUAL       ">="
%token T_EQUAL               "=="
%token T_NOT_EQUAL           "!="

%token T_AND                 "&&"
%token T_OR                  "||"
%token T_NOT                 "!"

%token T_ON                  "on"
%token T_SPACE               "space"
%token T_LEFTARROW           "leftarrow"
%token T_RIGHTARROW          "rightarrow"
%token T_UPARROW             "uparrow"
%token T_DOWNARROW           "downarrow"
%token T_LEFTMOUSE_DOWN      "leftmouse_down"
%token T_MIDDLEMOUSE_DOWN    "middlemouse_down"
%token T_RIGHTMOUSE_DOWN     "rightmouse_down"
%token T_LEFTMOUSE_UP        "leftmouse_up"
%token T_MIDDLEMOUSE_UP      "middlemouse_up"
%token T_RIGHTMOUSE_UP       "rightmouse_up"
%token T_MOUSE_MOVE          "mouse_move"
%token T_MOUSE_DRAG          "mouse_drag"
%token T_F1                  "f1"
%token T_AKEY                "akey"
%token T_SKEY                "skey"
%token T_DKEY                "dkey"
%token T_FKEY                "fkey"
%token T_HKEY                "hkey"
%token T_JKEY                "jkey"
%token T_KKEY                "kkey"
%token T_LKEY                "lkey"
%token T_WKEY                "wkey"
%token T_ZKEY                "zkey"

%token <union_string> T_ID            	 "identifier"
%token <union_int> T_INT_CONSTANT    "int constant"
%token <union_double> T_DOUBLE_CONSTANT "double constant"
%token <union_string> T_STRING_CONSTANT "string constant"
 /* special token that does not match any production */
 /* used for characters that are not part of the language */
%token T_ERROR               "error"

%type <union_gpl_type> simple_type
%type <union_gpl_type> object_type
%type <union_expression_ptr> primary_expression
%type <union_expression_ptr> expression
%type <union_expression_ptr> optional_initializer 
%type <union_expression_ptr> variable
%type <union_parameter_ptr> parameter_list
%type <union_parameter_ptr> parameter_list_or_empty
%type <union_parameter_ptr> parameter
%type <union_statement_ptr> statement 
%type <union_statement_ptr> statement_list 
%type <union_statement_ptr> statement_block 
%right T_ASSIGN T_PLUS_ASSIGN T_MINUS_ASSIGN
%left T_OR
%left T_AND
%left T_EQUAL T_NOT_EQUAL 
%left T_LESS T_GREATER T_LESS_EQUAL T_GREATER_EQUAL
%left T_PLUS T_MINUS
%left T_MULTIPLY T_DIVIDE T_MOD
%left T_NEAR T_TOUCHES
%nonassoc T_UNARY_OPS
%nonassoc T_IF_NO_ELSE
%nonassoc T_ELSE

%%
// updated January 2019

//---------------------------------------------------------------------
program:
    declaration_list block_list
    ;

//---------------------------------------------------------------------
declaration_list:
    declaration_list declaration
    | empty
    ;

//---------------------------------------------------------------------
declaration:
    variable_declaration T_SEMIC
    | object_declaration T_SEMIC
    | forward_declaration T_SEMIC
    ;

//---------------------------------------------------------------------
variable_declaration:
    simple_type T_ID  optional_initializer
    {
      Table_handler& th = Table_handler::instance();
      Expression* eptr = $3;
      Constant* cptr = (eptr==nullptr ? nullptr: eptr->evaluate());
      std::shared_ptr<Symbol> sym;
      switch($1){
        case INT:
	      {
	        int val;
	        try{
	          val=(cptr==nullptr)? 0 : cptr->as_int();
	        }
	        catch(Gpl_type thrown){
            Error::error(Error::INVALID_TYPE_FOR_INITIAL_VALUE, gpl_type_to_string(thrown), *$2, "int");
          }
	        sym = std::make_shared<Symbol>(*$2, new int(val));
	        break;
        }
	      case DOUBLE:
	      {
	        double val;
	        try{
            val=(cptr==nullptr)? 0.0 : cptr->as_double();
	        }
          catch(Gpl_type thrown){
            Error::error(Error::INVALID_TYPE_FOR_INITIAL_VALUE, gpl_type_to_string(thrown), *$2, "double");
          }
          sym = std::make_shared<Symbol>(*$2, new double(val));
	        break;
	      }
	      case STRING:
	      {
	        string val;
	        try{
            val=(cptr==nullptr)? "" : cptr->as_string();
	        }
          catch(Gpl_type thrown){
            Error::error(Error::INVALID_TYPE_FOR_INITIAL_VALUE, gpl_type_to_string(thrown), *$2, "string");
          }
          sym = std::make_shared<Symbol>(*$2, new std::string(val));
	        break;
	      }
        default:
        {
          std::cerr << "this shouldn't happen. 63426\n";
          sym = std::make_shared<Symbol>(*$2, new int(0));
          break;
        }
      }
      if(th.defined_in_current_scope(*$2))
      {
	      Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *$2);
	      delete $2;
        delete $3;
        break;
      }
      if(!th.insert(sym))
        std::cout << "bad happen in variable dec\n";
      delete $2;
      delete $3;
    }
    | simple_type T_ID T_LBRACKET expression T_RBRACKET
    {
      Table_handler& th = Table_handler::instance();
      int index = 0;
      try{
        index = $4->evaluate()->as_int();
      }catch(Gpl_type thrown){
        switch(thrown){
          case DOUBLE:
          {
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, "double", *$2);
            break;
          }
          case STRING:
          {
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, "string", *$2);
            break;
          }
          case RECTANGLE:
          {
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, "rectangle", *$2);
            break;
          }
          case CIRCLE:
          {
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, "circle", *$2);
            break;
          }
          case TEXTBOX:
          {
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, "textbox", *$2);
            break;
          }
          case TRIANGLE:
          {
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, "triangle", *$2);
            break;
          }
          case PIXMAP:
          {
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, "pixmap", *$2);
            break;
          }
          case ANIMATION_BLOCK:
          {
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, "animation block", *$2);
            break;
          }
        }
        delete $2;
        delete $4;
        break;
      }
      if(index < 1) {
        Error::error(Error::INVALID_ARRAY_SIZE, *$2, $4->evaluate()->as_string());
        index=1;
      }
      std::shared_ptr<Symbol> sym;
      switch($1){
	      case INT:
	      {
	        int* test = new int[index];
          for(int i = 0; i < index; i++)
	          test[i] = 0;
	        sym = std::make_shared<Symbol>(*$2, test, index);
	        break;
	      }
        case DOUBLE:
	      {
          double* test = new double[index];
	        for(int i = 0; i < index; i++)
	        test[i] = 0.0;
	        sym = std::make_shared<Symbol>(*$2, test, index);
      	  break;
	      } 
	      case STRING:
	      {
	        std::string* test = new std::string[index];
	        for(int i = 0; i < index; i++)
	          test[i] = "";
	        sym = std::make_shared<Symbol>(*$2, test, index);
	        break;
	      }
      }
      if(th.defined_in_current_scope(*$2))
      {
	      Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *$2);
	      delete $2;
	      delete $4;
        break;
      }
      th.insert(sym);
      delete $2;
      delete $4;
    }
    ;

//---------------------------------------------------------------------
simple_type:
    T_INT	{$$=INT;}
    | T_DOUBLE	{$$=DOUBLE;}
    | T_STRING	{$$=STRING;}
    ;

//---------------------------------------------------------------------
optional_initializer:
    T_ASSIGN expression {$$=$2;}
    | empty {$$=nullptr;}
    ;

//---------------------------------------------------------------------
object_declaration:
    object_type T_ID parameter_list_or_empty 
    {
      Table_handler& th = Table_handler::instance();
      std::shared_ptr<Symbol> sym;
      switch($1){
        case RECTANGLE:
        {
          sym = std::make_shared<Symbol>(*$2, new Rectangle());
          while($3 != nullptr){
            Parameter* list_end = $3;
            Parameter* prev = $3;
            while(list_end->next){
              prev = list_end;
              list_end = list_end->next;
            }
            std::string pname = list_end->name;
            Constant* cptr = list_end->expression->evaluate();
            try{
              bool match = false;
              if(((Rectangle::get_member_variable_type(pname) & DOUBLE) && cptr->type() <= DOUBLE)
                || ((Rectangle::get_member_variable_type(pname) & STRING) && cptr->type() <= STRING))
                match = true;
              if(!match && Rectangle::get_member_variable_type(pname) != cptr->type())
              {
                Error::error(Error::INCORRECT_CONSTRUCTOR_PARAMETER_TYPE, *$2, list_end->name);
              }else{
                try{
                  if(Rectangle::get_member_variable_type(pname) & INT){
                    sym->as_Rectangle()->set_member_variable(pname, cptr->as_int()); 
                  }else if(Rectangle::get_member_variable_type(pname) & DOUBLE){
                    sym->as_Rectangle()->set_member_variable(pname, cptr->as_double()); 
                  }else if(Rectangle::get_member_variable_type(pname) & STRING){
                    sym->as_Rectangle()->set_member_variable(pname, cptr->as_string()); 
                  //}else if(Rectangle::get_member_variable_type(pname) & ANIMATION_BLOCK){
                    //sym->as_Rectangle()->set_member_variable(pname, cptr->as_Animation_block()); 
                  }else{
                    std::cerr << "invalid parameter constant expression, somehow. adding sym with parameter of 0 int\n";
                    sym->as_Rectangle()->set_member_variable(*$2, 0); 
                  }
                }catch(...){
                  Error::error(Error::CANNOT_CHANGE_DERIVED_ATTRIBUTE, list_end->name, gpl_type_to_string($1));
                }
              }
            }catch(...){
              Error::error(Error::UNKNOWN_CONSTRUCTOR_PARAMETER, gpl_type_to_string($1), list_end->name);
            }
            delete list_end;
            if(list_end == $3)
              $3 = nullptr;
            else
              prev->next = nullptr;
          }   
	        break;
        }
        case CIRCLE:
        {
          sym = std::make_shared<Symbol>(*$2, new Circle());
          while($3 != nullptr){
            Parameter* list_end = $3;
            Parameter* prev = $3;
            while(list_end->next){
              prev = list_end;
              list_end = list_end->next;
            }
            std::string pname = list_end->name;
            Constant* cptr = list_end->expression->evaluate();
            try{
              bool match = false;
              if(((Circle::get_member_variable_type(pname) & DOUBLE) && cptr->type() <= DOUBLE)
                || ((Circle::get_member_variable_type(pname) & STRING) && cptr->type() <= STRING))
                match = true;
              if(!match && Circle::get_member_variable_type(pname) != cptr->type())
              {
                Error::error(Error::INCORRECT_CONSTRUCTOR_PARAMETER_TYPE, *$2, list_end->name);
              }else{
                try{
                  if(Circle::get_member_variable_type(pname) & INT){
                    sym->as_Circle()->set_member_variable(pname, cptr->as_int()); 
                  }else if(Circle::get_member_variable_type(pname) & DOUBLE){
                    sym->as_Circle()->set_member_variable(pname, cptr->as_double()); 
                  }else if(Circle::get_member_variable_type(pname) & STRING){
                    sym->as_Circle()->set_member_variable(pname, cptr->as_string()); 
                  //}else if(Circle::get_member_variable_type(pname) & ANIMATION_BLOCK){
                    //sym->as_Circle()->set_member_variable(pname, cptr->as_Animation_block()); 
                  }else{
                    std::cerr << "invalid parameter constant expression, somehow. adding sym with parameter of 0 int\n";
                    sym->as_Circle()->set_member_variable(*$2, 0); 
                  }
                }catch(...){
                  Error::error(Error::CANNOT_CHANGE_DERIVED_ATTRIBUTE, list_end->name, gpl_type_to_string($1));
                }
              }
            }catch(...){
              Error::error(Error::UNKNOWN_CONSTRUCTOR_PARAMETER, gpl_type_to_string($1), list_end->name);
            }
            delete list_end;
            if(list_end == $3)
              $3 = nullptr;
            else
              prev->next = nullptr;
          }   
	        break;
        }
        case TEXTBOX:
        {
          sym = std::make_shared<Symbol>(*$2, new Textbox());
          while($3 != nullptr){
            Parameter* list_end = $3;
            Parameter* prev = $3;
            while(list_end->next){
              prev = list_end;
              list_end = list_end->next;
            }
            std::string pname = list_end->name;
            Constant* cptr = list_end->expression->evaluate();
            try{
              bool match = false;
              if(((Textbox::get_member_variable_type(pname) & DOUBLE) && cptr->type() <= DOUBLE)
                || ((Textbox::get_member_variable_type(pname) & STRING) && cptr->type() <= STRING))
                match = true;
              if(!match && Textbox::get_member_variable_type(pname) != cptr->type())
              {
                Error::error(Error::INCORRECT_CONSTRUCTOR_PARAMETER_TYPE, *$2, list_end->name);
              }else{
                try{
                  if(Textbox::get_member_variable_type(pname) & INT){
                    sym->as_Textbox()->set_member_variable(pname, cptr->as_int()); 
                  }else if(Textbox::get_member_variable_type(pname) & DOUBLE){
                    sym->as_Textbox()->set_member_variable(pname, cptr->as_double()); 
                  }else if(Textbox::get_member_variable_type(pname) & STRING){
                    sym->as_Textbox()->set_member_variable(pname, cptr->as_string()); 
                  //}else if(Textbox::get_member_variable_type(pname) & ANIMATION_BLOCK){
                    //sym->as_Textbox()->set_member_variable(pname, cptr->as_Animation_block()); 
                  }else{
                    std::cerr << "invalid parameter constant expression, somehow. adding sym with parameter of 0 int\n";
                    sym->as_Textbox()->set_member_variable(*$2, 0); 
                  }
                }catch(...){
                  Error::error(Error::CANNOT_CHANGE_DERIVED_ATTRIBUTE, list_end->name, gpl_type_to_string($1));
                }
              }
            }catch(...){
              Error::error(Error::UNKNOWN_CONSTRUCTOR_PARAMETER, gpl_type_to_string($1), list_end->name);
            }
            delete list_end;
            if(list_end == $3)
              $3 = nullptr;
            else
              prev->next = nullptr;
          }   
	        break;
        } 
        case TRIANGLE:
        {
          sym = std::make_shared<Symbol>(*$2, new Triangle());
          while($3 != nullptr){
            Parameter* list_end = $3;
            Parameter* prev = $3;
            while(list_end->next){
              prev = list_end;
              list_end = list_end->next;
            }
            std::string pname = list_end->name;
            Constant* cptr = list_end->expression->evaluate();
            try{
              bool match = false;
              if(((Triangle::get_member_variable_type(pname) & DOUBLE) && cptr->type() <= DOUBLE)
                || ((Triangle::get_member_variable_type(pname) & STRING) && cptr->type() <= STRING))
                match = true;
              if(!match && Triangle::get_member_variable_type(pname) != cptr->type())
              {
                Error::error(Error::INCORRECT_CONSTRUCTOR_PARAMETER_TYPE, *$2, list_end->name);
              }else{
                try{
                  if(Triangle::get_member_variable_type(pname) & INT){
                    sym->as_Triangle()->set_member_variable(pname, cptr->as_int()); 
                  }else if(Triangle::get_member_variable_type(pname) & DOUBLE){
                    sym->as_Triangle()->set_member_variable(pname, cptr->as_double()); 
                  }else if(Triangle::get_member_variable_type(pname) & STRING){
                    sym->as_Triangle()->set_member_variable(pname, cptr->as_string()); 
                  //}else if(Triangle::get_member_variable_type(pname) & ANIMATION_BLOCK){
                    //sym->as_Triangle()->set_member_variable(pname, cptr->as_Animation_block()); 
                  }else{
                    std::cerr << "invalid parameter constant expression, somehow. adding sym with parameter of 0 int\n";
                    sym->as_Triangle()->set_member_variable(*$2, 0); 
                  }
                }catch(...){
                  Error::error(Error::CANNOT_CHANGE_DERIVED_ATTRIBUTE, list_end->name, gpl_type_to_string($1));
                }
              }
            }catch(...){
              Error::error(Error::UNKNOWN_CONSTRUCTOR_PARAMETER, gpl_type_to_string($1), list_end->name);
            }
            delete list_end;
            if(list_end == $3)
              $3 = nullptr;
            else
              prev->next = nullptr;
          }   
	        break;
        }
        case PIXMAP:
        {
          sym = std::make_shared<Symbol>(*$2, new Pixmap());
          while($3 != nullptr){
            Parameter* list_end = $3;
            Parameter* prev = $3;
            while(list_end->next){
              prev = list_end;
              list_end = list_end->next;
            }
            std::string pname = list_end->name;
            Constant* cptr = list_end->expression->evaluate();
            try{
              bool match = false;
              if(((Pixmap::get_member_variable_type(pname) & DOUBLE) && cptr->type() <= DOUBLE)
                || ((Pixmap::get_member_variable_type(pname) & STRING) && cptr->type() <= STRING))
                match = true;
              if(!match && Pixmap::get_member_variable_type(pname) != cptr->type())
              {
                Error::error(Error::INCORRECT_CONSTRUCTOR_PARAMETER_TYPE, *$2, list_end->name);
              }else{
                try{
                  if(Pixmap::get_member_variable_type(pname) & INT){
                    sym->as_Pixmap()->set_member_variable(pname, cptr->as_int()); 
                  }else if(Pixmap::get_member_variable_type(pname) & DOUBLE){
                    sym->as_Pixmap()->set_member_variable(pname, cptr->as_double()); 
                  }else if(Pixmap::get_member_variable_type(pname) & STRING){
                    sym->as_Pixmap()->set_member_variable(pname, cptr->as_string()); 
                  //}else if(Pixmap::get_member_variable_type(pname) & ANIMATION_BLOCK){
                    //sym->as_Pixmap()->set_member_variable(pname, cptr->as_Animation_block()); 
                  }else{
                    std::cerr << "invalid parameter constant expression, somehow. adding sym with parameter of 0 int\n";
                    sym->as_Pixmap()->set_member_variable(*$2, 0); 
                  }
                }catch(...){
                  Error::error(Error::CANNOT_CHANGE_DERIVED_ATTRIBUTE, list_end->name, gpl_type_to_string($1));
                }
              }
            }catch(...){
              Error::error(Error::UNKNOWN_CONSTRUCTOR_PARAMETER, gpl_type_to_string($1), list_end->name);
            }
            delete list_end;
            if(list_end == $3)
              $3 = nullptr;
            else
              prev->next = nullptr;
          }   
	        break;
        } 
        default:
          std::cerr << "This certainly shouldn't happen.\n";
          break;
      }
      if(th.defined_in_current_scope(*$2))
      {
	      Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *$2);
	      delete $2;
        delete $3;
        break;
      }
      th.insert(sym);
      delete $2;
      delete $3;
    }
    | object_type T_ID T_LBRACKET expression T_RBRACKET 
    {
      Table_handler& th = Table_handler::instance();
      int index = 0;
      try{
        index = $4->evaluate()->as_int();
      }catch(Gpl_type thrown){
        switch(thrown){
          case DOUBLE:
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, "double", *$2); 
            break;
          case STRING:
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, "string", *$2); 
            break;
          case RECTANGLE:
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, "rectangle", *$2);   
            break;
          case CIRCLE:
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, "circle", *$2);
            break;
          case TEXTBOX:
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, "textbox", *$2);
            break;
          case TRIANGLE:
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, "triangle", *$2);
            break;
          case PIXMAP:
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, "pixmap", *$2);
            break;
          case ANIMATION_BLOCK:
            Error::error(Error::ARRAY_SIZE_MUST_BE_AN_INTEGER, "animation block", *$2);
            break;
        }
        delete $2;
        delete $4;
        break;
      }
      if(index < 1) {
        Error::error(Error::INVALID_ARRAY_SIZE, *$2, $4->evaluate()->as_string());
        index = 1;
      }
      if(th.defined_in_current_scope(*$2))
      {
	      Error::error(Error::PREVIOUSLY_DECLARED_VARIABLE, *$2);
        break;
      }else{
        std::shared_ptr<Symbol> sym;
        Rectangle* rec;
        Circle* cir;
        Textbox* txt;
        Triangle* tri;
        Pixmap* pix;
        switch($1){
          case RECTANGLE:
            rec = new Rectangle[index];
            sym = std::make_shared<Symbol>(*$2, rec, index);
            break;
          case CIRCLE:
            cir = new Circle[index];
            sym = std::make_shared<Symbol>(*$2, cir, index);
            break;
          case TEXTBOX:
            txt = new Textbox[index];
            sym = std::make_shared<Symbol>(*$2, txt, index);
            break;
          case TRIANGLE:
            tri = new Triangle[index];
            sym = std::make_shared<Symbol>(*$2, tri, index);
            break;
          case PIXMAP:
            pix = new Pixmap[index];
            sym = std::make_shared<Symbol>(*$2, pix, index);
            break;
          default:
            std::cerr << "Invalid game object type 491243\n";
            break;
        }
        th.insert(sym);
      }
      delete $2;
      delete $4;
    }
    ;

//---------------------------------------------------------------------
object_type:
    T_TRIANGLE {$$ = TRIANGLE;}
    | T_PIXMAP {$$ = PIXMAP;}
    | T_CIRCLE {$$ = CIRCLE;}
    | T_RECTANGLE {$$ = RECTANGLE;}
    | T_TEXTBOX {$$ = TEXTBOX;}
    ;

//---------------------------------------------------------------------
parameter_list_or_empty:
    parameter_list {$$ = $1;}
    | T_LPAREN empty T_RPAREN {$$ = nullptr;}
    | empty {$$ = nullptr; /*CS degree meme*/}
    ;

//---------------------------------------------------------------------
parameter_list :
    parameter_list T_COMMA parameter 
    {
      Parameter* list_end = $1;
      while(list_end->next != nullptr)
        list_end = list_end->next;
      list_end->next = $3;
      $$ = $1;
    }
    | parameter {$$ = $1; /*CS degree meme*/}
    ;

//---------------------------------------------------------------------
parameter:
    T_ID T_ASSIGN expression {
      Parameter* asdf = new Parameter; 
      asdf->expression = $3; 
      asdf->name = *$1; 
      asdf->next = nullptr; 
      $$ = asdf;}

    ;

//---------------------------------------------------------------------
forward_declaration:
    T_FORWARD T_ANIMATION T_ID T_LPAREN animation_parameter T_RPAREN {$3; /*CHANGE*/}
    ;

//---------------------------------------------------------------------
block_list:
    block_list block
    | empty
    ;

//---------------------------------------------------------------------
block:
    initialization_block
    | termination_block
    | animation_block
    | on_block
    ;

//---------------------------------------------------------------------
initialization_block:
    T_INITIALIZATION statement_block
    ;

//---------------------------------------------------------------------
termination_block:
    T_TERMINATION statement_block
    ;

//---------------------------------------------------------------------
animation_block:
    T_ANIMATION T_ID T_LPAREN check_animation_parameter T_RPAREN T_LBRACE statement_list T_RBRACE {$2; /*CHANGE*/}
    ;

//---------------------------------------------------------------------
animation_parameter:
    object_type T_ID {$2; /*CHANGE*/}
    ;

//---------------------------------------------------------------------
check_animation_parameter:
    object_type T_ID{$2; /*CHANGE*/}
    ;

//---------------------------------------------------------------------
on_block:
    T_ON keystroke statement_block 
    {
      Event_manager::instance().add_handler($2, $3);
    }
    ;

//---------------------------------------------------------------------
keystroke:
    T_SPACE {$$ = Window::SPACE;}
    | T_UPARROW
    | T_DOWNARROW
    | T_LEFTARROW
    | T_RIGHTARROW
    | T_LEFTMOUSE_DOWN
    | T_MIDDLEMOUSE_DOWN
    | T_RIGHTMOUSE_DOWN
    | T_LEFTMOUSE_UP
    | T_MIDDLEMOUSE_UP
    | T_RIGHTMOUSE_UP
    | T_MOUSE_MOVE
    | T_MOUSE_DRAG
    | T_AKEY
    | T_SKEY
    | T_DKEY
    | T_FKEY
    | T_HKEY
    | T_JKEY
    | T_KKEY
    | T_LKEY
    | T_WKEY
    | T_ZKEY
    | T_F1
    ;

//---------------------------------------------------------------------
statement_or_block_of_statements:
    statement_block
    | statement
    ;

//---------------------------------------------------------------------
statement_block:
    T_LBRACE statement_list T_RBRACE {$$ = $2;}
    | T_LBRACE T_RBRACE {$$ = nullptr;}
    ;


//---------------------------------------------------------------------
statement_list:
    statement_list statement { $1->append_statement($2); $$ = $1;}
    | statement {$$ = $1;}
    ;

//---------------------------------------------------------------------
statement:
    if_statement{$$ = nullptr; /*CHANGE*/}
    | for_statement{$$ = nullptr; /*CHANGE*/}
    | assign_statement T_SEMIC{$$ = nullptr; /*CHANGE*/}
    | print_statement T_SEMIC{$$ = nullptr; /*CHANGE*/}
    | exit_statement T_SEMIC{$$ = nullptr; /*CHANGE*/}
    ;

//---------------------------------------------------------------------
if_statement:
    T_IF T_LPAREN expression T_RPAREN statement_or_block_of_statements %prec T_IF_NO_ELSE
    | T_IF T_LPAREN expression T_RPAREN statement_or_block_of_statements T_ELSE statement_or_block_of_statements
    ;

//---------------------------------------------------------------------
for_statement:
    T_FOR T_LPAREN assign_statement_or_empty T_SEMIC expression T_SEMIC assign_statement_or_empty T_RPAREN statement_or_block_of_statements
    ;

//---------------------------------------------------------------------
print_statement:
    T_PRINT T_LPAREN expression T_RPAREN {$$ = new Print(Line_count, $3);}
    ;

//---------------------------------------------------------------------
exit_statement:
    T_EXIT T_LPAREN expression T_RPAREN
    ;

//---------------------------------------------------------------------
assign_statement_or_empty:
    assign_statement
    | empty
    ;

//---------------------------------------------------------------------
assign_statement:
    variable T_ASSIGN expression
    | variable T_PLUS_ASSIGN expression
    | variable T_MINUS_ASSIGN expression
    | variable T_PLUS_PLUS
    | variable T_MINUS_MINUS
    ;

//---------------------------------------------------------------------
variable:
    T_ID
    {
      Table_handler& th = Table_handler::instance();
      if(!th.defined_in_current_scope(*$1))
      {
	      Error::error(Error::UNDECLARED_VARIABLE, *$1);
	      delete $1;
        $$ = new Integer_constant(0);
      	break;
      }
      std::shared_ptr<Symbol> matching = th.lookup(*$1);
      if(matching->is_array()){
        Error::error(Error::VARIABLE_IS_AN_ARRAY, *$1);
        delete $1;
        $$ = new Integer_constant(0);
        break;
      }
      $$ = new Variable(matching);
      delete $1;
    }
    | T_ID T_LBRACKET expression T_RBRACKET
    { 
      //get table handler, lookup symbol $3 and only execute next line if it's there
      Table_handler& th = Table_handler::instance();
      if(!th.defined_in_current_scope(*$1))
      {
	      Error::error(Error::UNDECLARED_VARIABLE, *$1+"[]");
	      delete $1;
        delete $3;
        $$ = new Integer_constant(0);
        break;
      }
      std::shared_ptr<Symbol> matching = th.lookup(*$1);
      //if the symbol is not an array, throw an error
      if(!matching->get_type() & ARRAY){
        Error::error(Error::VARIABLE_NOT_AN_ARRAY, *$1);
        delete $1;
        delete $3;
        $$ = new Integer_constant(0);
        break;
      }
      Expression* expr = $3;
      switch(expr->type()){
        case INT:
          break;
        case DOUBLE:
          Error::error(Error::ARRAY_INDEX_MUST_BE_AN_INTEGER, *$1, "A double expression");
          delete $3;
          expr = new Integer_constant(0);
          break;
        case STRING:
          Error::error(Error::ARRAY_INDEX_MUST_BE_AN_INTEGER, *$1, "A string expression");
          delete $3;
          expr = new Integer_constant(0);
          break;
        case RECTANGLE:
          Error::error(Error::ARRAY_INDEX_MUST_BE_AN_INTEGER, *$1, "A rectangle expression");
          delete $3;
          expr = new Integer_constant(0);
          break;
        case CIRCLE:
          Error::error(Error::ARRAY_INDEX_MUST_BE_AN_INTEGER, *$1, "A circle expression");
          delete $3;
          expr = new Integer_constant(0);
          break;
        case TEXTBOX:
          Error::error(Error::ARRAY_INDEX_MUST_BE_AN_INTEGER, *$1, "A textbox expression");
          delete $3;
          expr = new Integer_constant(0);
          break;
       case TRIANGLE:
          Error::error(Error::ARRAY_INDEX_MUST_BE_AN_INTEGER, *$1, "A triangle expression");
          delete $3;
          expr = new Integer_constant(0);
          break;
       case PIXMAP:
          Error::error(Error::ARRAY_INDEX_MUST_BE_AN_INTEGER, *$1, "A pixmap expression");
          delete $3;
          expr = new Integer_constant(0);
          break;
        case ANIMATION_BLOCK:
          Error::error(Error::ARRAY_INDEX_MUST_BE_AN_INTEGER, *$1, "An animation_block expression");
          delete $3;
          expr = new Integer_constant(0);
          break;
        default:
          //assert(false);
          std::cerr << "bad happen var production 12312\n";
          break;
      }
      $$ = new Variable(matching, expr);
      delete $1;
    } 
    | T_ID T_PERIOD T_ID 
    {
      Table_handler& th = Table_handler::instance();
      std::shared_ptr<Symbol> sym = th.lookup(*$1);
      if(!sym)
      {
	      Error::error(Error::UNDECLARED_VARIABLE, *$1);
	      delete $1;
        delete $3;
        $$ = new Integer_constant(0);
        break;
      }
      if(sym->is_array())
      {
        Error::error(Error::VARIABLE_IS_AN_ARRAY, *$1);
        delete $1;
        delete $3;
        $$ = new Integer_constant(0);
        break;
      }
      try{
        switch(sym->get_type()){
          case RECTANGLE:
            Rectangle::get_member_variable_type(*$3);
            break;
          case CIRCLE:
            Circle::get_member_variable_type(*$3);
            break;
          case TEXTBOX:
            Textbox::get_member_variable_type(*$3);
            break;
          case TRIANGLE:
            Triangle::get_member_variable_type(*$3);
            break;
          case PIXMAP:
            Pixmap::get_member_variable_type(*$3);
            break;
        }
      }catch(...){
        Error::error(Error::UNDECLARED_MEMBER, *$1, *$3);
        delete $1;
        delete $3;
        $$ = new Integer_constant(0);
        break;
      }
      Member_variable* mem = new Member_variable(sym, *$3);
      $$ = mem->evaluate(); 
    }
    | T_ID T_LBRACKET expression T_RBRACKET T_PERIOD T_ID 
    {
     Table_handler& th = Table_handler::instance();
      std::shared_ptr<Symbol> sym = th.lookup(*$1);
      if(!sym)
      {
	      Error::error(Error::UNDECLARED_VARIABLE, *$1);
	      delete $1;
        delete $3;
        delete $6;
        $$ = new Integer_constant(0);
        break;
      }
      if(!sym->is_array())
      {
        Error::error(Error::VARIABLE_NOT_AN_ARRAY, *$1);
        delete $1;
        delete $3;
        delete $6;
        $$ = new Integer_constant(0);
        break;
      }
      try{
        switch(sym->get_type() ^ ARRAY){
          case RECTANGLE:
            Rectangle::get_member_variable_type(*$6);
            break;
          case CIRCLE:
            Circle::get_member_variable_type(*$6);
            break;
          case TEXTBOX:
            Textbox::get_member_variable_type(*$6);
            break;
          case TRIANGLE:
            Triangle::get_member_variable_type(*$6);
            break;
          case PIXMAP:
            Pixmap::get_member_variable_type(*$6);
            break;
        }
      }catch(...){
        Error::error(Error::UNDECLARED_MEMBER, *$1, *$6);
        delete $1;
        delete $3;
        delete $6;
        $$ = new Integer_constant(0);
        break;
      }
      Member_variable* mem;
      switch(sym->get_type() ^ ARRAY){
        case RECTANGLE:
          mem = new Member_variable(sym, $3, *$6);
          break;
        case CIRCLE:
          mem = new Member_variable(sym, $3, *$6);
          break;
        case TEXTBOX:
          mem = new Member_variable(sym, $3, *$6);
          break;
        case TRIANGLE:
          mem = new Member_variable(sym, $3, *$6);
          break;
        case PIXMAP:
          mem = new Member_variable(sym, $3, *$6);
          break;
      }    
      $$ = mem->evaluate(); 
    }
    ;

//---------------------------------------------------------------------
expression: 
    primary_expression{$$=$1;}
    | expression T_OR expression  {$$ = Bin_op_check<Or, OR>($1, $3, (INT|DOUBLE));}
    | expression T_AND expression {$$ = Bin_op_check<And, AND>($1, $3, (INT|DOUBLE));}
    | expression T_LESS_EQUAL expression {$$ = Bin_op_check<Less_equal, LESS_EQUAL>($1, $3, (INT|DOUBLE|STRING));}
    | expression T_GREATER_EQUAL  expression {$$ = Bin_op_check<Greater_equal, GREATER_EQUAL>($1, $3, (INT|DOUBLE|STRING));}
    | expression T_LESS expression {$$ = Bin_op_check<Less_than, LESS_THAN>($1, $3, (INT|DOUBLE|STRING));}
    | expression T_GREATER  expression {$$ = Bin_op_check<Greater_than, GREATER_THAN>($1, $3, (INT|DOUBLE|STRING));}
    | expression T_EQUAL expression {$$ = Bin_op_check<Equal, EQUAL>($1, $3, (INT|DOUBLE|STRING));}
    | expression T_NOT_EQUAL expression {$$ = Bin_op_check<Not_equal, NOT_EQUAL>($1, $3, (INT|DOUBLE|STRING));}
    | expression T_PLUS expression {$$ = Bin_op_check<Plus, PLUS>($1, $3, (INT|DOUBLE|STRING));}
    | expression T_MINUS expression  {$$= Bin_op_check<Minus, MINUS>($1, $3, (INT|DOUBLE));}
    | expression T_MULTIPLY expression {$$ = Bin_op_check<Multiply, MULTIPLY>($1, $3, (INT|DOUBLE));}
    | expression T_DIVIDE expression 
    {
      if(($3->type()&(INT|DOUBLE)) && ($3->evaluate()->as_double() == 0 )){
        Error::error(Error::DIVIDE_BY_ZERO_AT_PARSE_TIME);
        delete $3;
        delete $1;
        $$ = new Integer_constant(0);
      }else{
        $$ = Bin_op_check<Divide, DIVIDE>($1, $3, (INT|DOUBLE));
      }
    }
    | expression T_MOD expression 
    {
      if(($3->type()&(INT)) && ($3->evaluate()->as_int() == 0 )){
        Error::error(Error::MOD_BY_ZERO_AT_PARSE_TIME);
        delete $3;
        delete $1;
        $$ = new Integer_constant(0);
      }else{
        $$ = Bin_op_check<Mod, MOD>($1, $3, (INT));
      }
    }
    | T_MINUS expression %prec T_UNARY_OPS      {$$ = Un_op_check<Unary_minus, UNARY_MINUS>($2, (INT|DOUBLE));}
    | T_NOT expression %prec T_UNARY_OPS        {$$ = Un_op_check<Not, NOT>($2, (INT|DOUBLE));}
    | T_SIN T_LPAREN expression T_RPAREN        {$$ = Un_op_check<Sine, SIN>($3, (INT|DOUBLE));}
    | T_COS T_LPAREN expression T_RPAREN        {$$ = Un_op_check<Cosine, COS>($3, (INT|DOUBLE));}
    | T_TAN T_LPAREN expression T_RPAREN        {$$ = Un_op_check<Tan, TAN>($3, (INT|DOUBLE));}
    | T_ASIN T_LPAREN expression T_RPAREN       {$$ = Un_op_check<Asin, ASIN>($3, (INT|DOUBLE));}   
    | T_ACOS T_LPAREN expression T_RPAREN       {$$ = Un_op_check<Acos, ACOS>($3, (INT|DOUBLE));}
    | T_ATAN T_LPAREN expression T_RPAREN       {$$ = Un_op_check<Atan, ATAN>($3, (INT|DOUBLE));}
    | T_SQRT T_LPAREN expression T_RPAREN       {$$ = Un_op_check<Sqrt, SQRT>($3, (INT|DOUBLE));}
    | T_ABS T_LPAREN expression T_RPAREN        {$$ = Un_op_check<Abs, ABS>($3, (INT|DOUBLE));}
    | T_FLOOR T_LPAREN expression T_RPAREN      {$$ = Un_op_check<Floor, FLOOR>($3, (INT|DOUBLE));}
    | T_RANDOM T_LPAREN expression T_RPAREN     {$$ = Un_op_check<Random, RANDOM>($3, (INT|DOUBLE));}
    | expression T_NEAR expression              {$$=nullptr;/*CHANGE*/}
    | expression T_TOUCHES expression           {$$=nullptr;/*CHANGE*/}
    ;

/*template <typename, Operator_type>
Expression* Bin_op_check(Expression* one, Expression* three, unsigned int valid_types)*/
//---------------------------------------------------------------------
primary_expression:
    T_LPAREN  expression T_RPAREN{$$=$2;}
    | variable {$$ = $1;}
    | T_INT_CONSTANT {$$ = new Integer_constant($1);}
    | T_TRUE{$$ = new Integer_constant(1);}
    | T_FALSE{$$ = new Integer_constant(0);}
    | T_DOUBLE_CONSTANT{$$ = new Double_constant($1);}
    | T_STRING_CONSTANT{$$ = new String_constant(*$1); delete $1;}
    ;

//---------------------------------------------------------------------
empty:
    // empty goes to nothing so that you can use empty in productions
    // when you want a production to go to nothing
    ;
%%
